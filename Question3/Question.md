# Question
3. (30 pts) Coding is converting a string to a sequence of 0 's and 1 's which is called the code of this string. A coding is called `decodable` if any code generated by this coding can be reversed to the original string. To prevent ambiguities in decoding, a "prefix rule" needs to be satisfied. The prefix rule states that no code is a prefix of another code. To encode English words, designing a coding for letters is a typical step. In this problem, we concentrate on designing a coding for the `26` letters without considering **uppercase** and **lowercase** (i.e. a, b, ..., z ). A straightforward coding for the letters is to use 5-digit binaries (e.g. `00000` for a `00001` for, b, and `00010` for c ). This type of coding is called `fixed-length coding`. This coding, though very simple, may not be inefficient in terms of the lengths of resulting codes. Typically, the resulting codes are expected to be as short as possible in average. It can be observed that, in a given document, the frequencies of letters can be significantly different. Intuitively, if the codes for frequent letters are shorter than the codes for infrequent letters, then the average length of codes of words is reduced. This type of coding is called `variable-length coding`.

- For example, given a sentence `"fanchao is a super cool person"`, the letters o, a and s are more frequent than others, and their codes can be designed to be shorter than others. Note that, when designing variable-length coding methods, the frequencies of letters are needed beforehand. And typically these frequencies are obtained from considered documents. In this problem, we consider the sentence `"fanchao is a super cool person"` as the given document. Please design a variable-length and decodable coding for the letters occurring in this document. Your coding is required to outperform the fixed-length coding (i.e. using 4-digit binaries to encode letters). Please justify that your coding is decodable. Please justify that your coding outperforms the 4-digit fixed-length coding.

# Answer
A popular way to apply fixed-length coding is Huffman coding, which is what we will use for this question. To ensure that the variable length is decodable we need to follow the prefix rule, which is that no code is allowed to be a prefix of any other code and the Huffman coding follows this rule so decoding will not be an issue. The basic concept of Huffman coding is to find the frequencies of characters and give them shorter codes so that the total memery taken is lesser. In this case using the sentence `"fanchao is a super cool person"` we first find the frequencies of each of the characters: 
'a' = 4 'c' = 3 'e' = 2 
'f' = 1 'h' = 1 'i' = 2
'l' = 1 'n' = 2 'o' = 5
'p' = 2 'r' = 2 's' = 3
'u' = 1

Using this information we now know to give 'o' the smallest code and 'u' the largest. Huffman coding works by constructing a binary tree where each leaf node represents a letter and its frequency. To get the actual codes for each character, binary codes are assigned to each letter based on its position in the tree. Starting from the root, every left branch is assigned a '0' and every right branch a '1'. This is how the codes are produced for each of the characters to simplify this we can just use an online calculator which gives us:
'o' → 00 'c' → 010 'e' → 0110
'i' → 0111 'f' → 10000 'h' → 10001
'l' → 10010 'u' → 10011 'p' → 1010 'n' → 1011
'r' → 1100 's' → 1101 'a' → 111

Now this is better than fixed-length coding as variable-length Huffman coding ensures that the average number of bits used for encoding each letter is minimized based on its frequency. In comparison, the fixed-length coding would assign a 4-bit binary code to each of the letters, resulting in inefficient encoding with unnecessary padding for less frequent letters.

When we compare the total number of bits required for both methods, the fixed-length coding requires 116 bits. While, Huffman coding uses 87 bits, which is more efficient. This paired with the fact that none of the codes are prefixes to any of the other codes means that its both more efficient and decodable.
